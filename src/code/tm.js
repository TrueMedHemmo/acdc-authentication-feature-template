function getMergedEdges(e){let t=getBGRChannels(e),n=[];for(let e=0;e<t.size()-1;e++){let c=t.get(e);const r=new cv.Size(5,5);cv.GaussianBlur(c,c,r,1,1,cv.BORDER_DEFAULT);let o=new cv.Mat,a=cv.threshold(c,o,0,255,cv.THRESH_OTSU);cv.Canny(c,c,.4*a,a,3),cv.dilate(c,c,new cv.Mat,new cv.Point(-1,-1),3,cv.BORDER_CONSTANT,new cv.Scalar(0,0,0)),cv.erode(c,c,new cv.Mat(2,2,cv.CV_8U)),cv.bitwise_not(c,c),n.push(c)}let c=null;for(let e=0;e<n.length;e++)null==c?(c=n[e].clone(),n[e].delete()):(cv.bitwise_and(c,n[e],c),n[e].delete());return cv.bitwise_not(c,c),c}function getBGRChannels(e){let t=new cv.MatVector;return cv.split(e,t),t}function getEdges(e){let t=e.clone();cv.cvtColor(t,t,cv.COLOR_RGB2GRAY,0);const n=new cv.Size(5,5);cv.GaussianBlur(t,t,n,1,1,cv.BORDER_DEFAULT);let c=new cv.Mat,r=cv.threshold(t,c,0,255,cv.THRESH_OTSU);return cv.Canny(t,t,.4*r,r,3),cv.dilate(t,t,new cv.Mat,new cv.Point(-1,-1),3,cv.BORDER_CONSTANT,new cv.Scalar(0,0,0)),cv.erode(t,t,new cv.Mat(2,2,cv.CV_8U)),c.delete(),t}function applyMaskToEdgeDetection(e,t){let n=e.clone();return n.setTo(new cv.Scalar(0,0,0)),cv.rectangle(n,t,new cv.Scalar(255,255,255),-1),cv.bitwise_and(e,n,e),e}function getContoursForEdges(e){let t=new cv.MatVector;return cv.findContours(e,t,new cv.Mat,cv.RETR_TREE,cv.CHAIN_APPROX_SIMPLE),t}function getLargestContourIDs(e,t,n,c){let r=0,o=0,a=0,i=0;if(e.size()<1)return[];for(let s=0;s<e.size();s++){let v=e.get(s),u=cv.minAreaRect(v),l=cv.RotatedRect.points(u);if(null!=t){let e=!1,v=4;if(l.forEach((r,o,a)=>{c&&(r.x<=t.x+v&&(e=!0),r.x>=t.x+t.width-v&&(e=!0)),n&&(r.y<=t.y+v&&(e=!0),r.y>=t.y+t.height-v&&(e=!0))}),!e){let e=cv.RotatedRect.boundingRect(u),t=e.width*e.height;t>r?(i=a,o=r,r=t,a=s):t>o&&(o=t,i=s)}}}return[a,i]}function getCornersForEdges(e){let t=new cv.MatVector;if(cv.findContours(e,t,new cv.Mat,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE),t.size()>1){let e=t.get(0);2===t.size()&&(e=t.get(1));let n=cv.arcLength(e,!0),c=new cv.Mat,r=new cv.MatVector;return cv.approxPolyDP(e,c,.05*n,!0),r.push_back(c),r}return null}function getCornersForContour(e){let t=cv.arcLength(e,!0),n=new cv.Mat,c=new cv.MatVector;return cv.approxPolyDP(e,n,.05*t,!0),c.push_back(n),c}function combinedRect(e,t){let n=cv.minAreaRect(e),c=cv.minAreaRect(t),r=cv.RotatedRect.boundingRect(n),o=cv.RotatedRect.boundingRect(c);if(calculateDistanceXToOtherContour(r,o)<=15||calculateDistanceYToOtherContour(r,o)<=15){let e,t,n,c;return e=r.x<o.x?r.x:o.x,n=r.y<o.y?r.y:o.y,t=r.x+r.width>o.x+o.width?r.width:o.width,c=r.y+r.height>o.y+o.height?r.height:o.height,new cv.Rect(e,n,t,c)}return r}function calculateDistanceYToOtherContour(e,t){return Math.abs(e.y-t.y)+Math.abs(e.y+e.height-(t.y+t.height))}function calculateDistanceXToOtherContour(e,t){return Math.abs(e.x-t.x)+Math.abs(e.x+e.width-(t.x+t.width))}class FrameData{constructor(e,t){var n=e,c=t;this.getContours=function(){return n},this.getSize=function(){return c},this.getCombinedRect=function(){return combinedRect(n[0],n[1])},this.getCenter=function(){let e=cv.minAreaRect(n[0]),c=cv.RotatedRect.boundingRect(e),r=c.x+c.width/2,o=c.y+c.height/2,a=r/t.width,i=o/t.height;return new cv.Point(a,i)},this.getAngle=function(){let e=cv.minAreaRect(n[0]);return Math.abs(e.angle)}}}export default{getEdges:getEdges,applyMaskToEdgeDetection:applyMaskToEdgeDetection,getContoursForEdges:getContoursForEdges,getLargestContourIDs:getLargestContourIDs,getMergedEdges:getMergedEdges,FrameData:FrameData,getCornersForEdges:getCornersForEdges,getCornersForContour:getCornersForContour};